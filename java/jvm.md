# JVM 内存结构 和 GC
### [go back](/java.md)      
### [go home](../README.md)     
## jvm内存结构
#### 图解
![图片](/static/img/v2-abefb713de46f1e6dd241246c0afe263_r.jpg)    
#### 分为 5个部分
+ 方法区(method area):线程共享,抛OutOfMemoryError异常,
+ 堆 (heap):线程共享,抛OutOfMemoryError异常,
+ 虚拟机栈 (VM stack):线程私有,抛OutOfMemoryError异常,StackOverflowError,
+ 本地方法区 (nation method stack):线程私有,抛OutOfMemoryError异常,StackOverflowError,
+ 程序计数器 (program counter register):线程私有,不会抛异常        
StackOverflowError异常:栈溢出,线程请求的栈深度大于jvm允许的栈的深度      
OutOfMemoryError异常:jvm动态扩展(例如你声明了一个 巨大的数组),无法申请到足够的内存    
#### 盗图一张
![图片](/static/img/20171007110030253.png)     
在Java中，Main函数就是栈的起始点，也是程序的起始点   
程序运行永远都是在栈中进行的，因而参数传递时，只存在传递基本类型和对象引用的问题。不会直接传对象本身。    
##### OOM 分为两种情况  内存溢出和内存泄露
+ 内存溢出.就是你申请内存的时候发现没有足够的内存了,例如声明大数组,或者SOF(Stack Overflow)虚拟机栈的溢出,
分为上溢(栈满还进栈),下溢(栈空还出栈),例如你能弄个递归,没有跳出条件 不停的递归.
+ 内存泄露.就是本来想释放内存,但是没有释放成功,这样一次没事,长久累积导致内存不够用

#### 方法区(method area)
线程共享,用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据,这里有一个**永久代**的概念,方法区是
java虚拟机对永久代的一种实现,但是1.8的时候没有永久代了,取而代之的是**元空间**,1.8的时候方法区也并入了元空间,元空间依赖于机器
内存不在依赖于jvm内存,因此基本不会出现内存溢出,可以通过
+ -XX:MaxMetaspaceSize进行增长上限的最大值设置，默认值为4G
+ -XX:MetaspaceSize进行设置初始化大小，默认值为20.8M

#### 堆 (heap)
线程共享,Java堆在虚拟机启动时创建，是Java虚拟机所管理的内存中最大的一块。
Java堆的唯一目的就是存放对象实例和数组,GC程序主要工作的地方
#### 虚拟机栈 (VM stack)
线程私有,生命周期与线程相同,每个java方法在执行的同时，都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息   
见下图:
![图片](/static/img/get14.png)    
#### 本地方法区 (nation method stack)
线程私有,jvm 调用Native方法服务,c/c++语言接口之类的时候使用,与**虚拟机栈**类似只不过是执行native方法
#### 程序计数器 (program counter register)
线程最后翻译成cpu指令之后,cpu执行线程命令的计数器,记录每个线程执行到哪一步了

## 堆(heap)的GC回收机制
heap 分为新生代和老年代,新生代又分为伊甸园,幸存者1,幸存者2
#### 老年代 经过多次新生代GC还存活下来的对象,或者是对象特别大直接进入老年代,采用**标记整理法GC**
#### 新生代 采取**复制算法**进行GC
+ 伊甸园:新创建的对象实例会放到伊甸园
+ 幸存者1/2:伊甸园满后会触发minor GC(次要GC),将存活的对象复制幸存者1,并且把幸存者2中的存活对象也复制到幸存者1,
保证两个幸存者空间有一个是空的,    
===================================
+ 标记整理法,会暂停jvm标记所有存活的对象,然后把他们都放到内存的一端,清除没有被标记存活的对象,保证内存的连续性
+ 复制法,会复制存活的对象从A区到另一个B区,之后把A区全部清空,不会暂停jvm
#### 针对spark程序的GC 调试
#调整堆大小这个东西一般调不了 运维都设置好了,还可以设置 新生代大小比例,GC指定GC的算法等
+ -Xms:初始堆大小
+ -Xmx:最大堆大小
+ -Xmn:最小堆大小
# 比较有用的调试命令
+ -XX:+PrintGCDetails:打印GC日志可以通过日志观察GC的类型和频繁程度,进而判断程序中具体引起GC的地方,再进行优化
+ -XX:+PrintHeapAtGC:GC前后的详细堆信息
## jvm常用命令
+ jps:查看jvm运行的**进程**,注意是进程
+ jstack:jstack 30316 线程快照
+ jmap -heap 31846:线程堆的使用情况

## 1.7 1.8 版本的区别
+ **在JDK1.7之前**运行时常量池逻辑包含**字符串常量池**存放在方法区, 此时hotspot虚拟机对**方法区**的实现为**永久代**
+ **在JDK1.7** 字符串常量池被从方法区拿到了堆中
+ **在JDK1.8和之后** hotspot移除了**永久代**用**元空间(Metaspace)**取而代之,
 这时候**字符串常量池**还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)  
 如下图
 ![图片](/static/img/get15.png)  
 ![图片](/static/img/get16.png)  
#### 联系邮箱 xxx_xxx@aliyun.com

